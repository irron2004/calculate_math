아주 좋습니다. **“디아블로식 스킬 트리”**를 첫 화면에 도입하는 전체 기획·설계안을 아래에 정리했습니다.
(성공 응답은 **평문 JSON**, 오류는 **RFC 9457** 기준으로 설계했고, 접근성·아동 서비스 정책도 함께 반영했습니다.)

---

## 1. 로드맵

### OKR (스킬 트리 도입 전용, 4주)

* **O1. 러닝 경로 가시화**: 첫 화면 스킬 트리(모바일/태블릿 최적화) 공개

  * KR1: TTI ≤ 3s, 초기 렌더 ≤ 50ms(인터랙션 준비)
  * KR2: 초회 방문 대비 **세션 시작률 +15%** (스킬 선택 → 연습 시작)
* **O2. 학습 진행도 연동**: 스킬 잠금 해제/숙련도 규칙 연결

  * KR1: 유저 진행도 기준으로 노드 잠금/해제 정확도 100%
  * KR2: ‘보스전(평가)’ 통과→다음 티어 해제 플로우 완성
* **O3. 품질/관측**

  * KR1: E2E(트리 렌더→스킬 선택→세션 시작) 자동화
  * KR2: KPI(Problems Served, Attempts, Correct Rate, **skill_unlocked**) 대시보드

### 마일스톤(주 단위)

* **W1**: 커리큘럼→DAG 모델링, 시드 JSON·API 초안, 잠금 규칙 엔진
* **W2**: React 스킬 트리 UI(React Flow 또는 Cytoscape) + 키보드 내비·리더 텍스트
* **W3**: 진행도 연동(세션 결과→XP/숙련도 갱신), ‘보스전’ 평가 라우트
* **W4**: A/B 실험(트리 vs 리스트), 로드/성능 최적화, 문서화·데이터 파이프라인

---

## 2. 백로그 세분화

> 표기: **P0/1/2** · **예상시간(h)** · **담당: 나** · **DoD**

### Epic A. 커리큘럼 DAG & 규칙 엔진

1. **스킬 그래프 스키마 정의 + 시드 작성** — P0 · 6h · 나

   * DoD: `skills.json`(nodes/edges), 토폴로지 검증 스크립트, 순환 감지
2. **잠금 규칙 엔진**(ALL/ANY, 최소 숙련도, 보스전 통과) — P0 · 6h · 나

   * DoD: `is_unlocked(user_progress, node)` 단위테스트 15케이스

### Epic B. API & 저장소

3. **GET /api/v1/skills/tree**(유저 진행도 포함) — P0 · 4h · 나

   * DoD: 평문 JSON, 캐시 키(`version:user_id`), 200/4xx/5xx 테스트
4. **POST /api/v1/skills/progress**(세션 결과→XP/숙련도 반영) — P0 · 6h · 나

   * DoD: 오답 2회 자동패스 영향 반영, 레이스 컨디션 방지(낙관락)

### Epic C. 프론트 UI

5. **스킬 트리 컴포넌트**(팬/줌/키보드 내비/리더 텍스트) — P0 · 10h · 나

   * DoD: 모바일 48dp 터치 타겟, WCAG AA 대비, `aria-describedby` 제공
6. **노드 상태 표현**(Locked/Unlockable/Unlocked/Mastered) — P0 · 4h · 나

   * DoD: 색·아이콘·툴팁·i18n 키 연결, 스냅샷 테스트

### Epic D. 평가·보스전

7. **티어 평가(보스전) 라우트** — P1 · 8h · 나

   * DoD: 합격선/재도전 쿨다운(시간 제한 없이), 통과 시 다음 티어 일괄 해제

### Epic E. 관측/지표

8. **이벤트/대시보드** — P0 · 5h · 나

   * DoD: `skill_viewed`, `skill_unlocked`, `boss_passed`, `session_started_from_tree`

### Epic F. 문서/운영

9. **콘텐츠 가이드**(i18n/난이도 문구/아이콘) — P1 · 4h · 나
10. **A/B 실험 설계**(트리 vs 리스트) — P2 · 6h · 나

---

## 3. 첫 번째 스프린트 계획 (2주)

* **포함 스토리**: 1, 2, 3, 5, 6, 8
* **리스크**: 레이아웃 알고리즘(작은 화면 가독성), 순환 의존 삽입 실수, 성능(노드 50+)
* **완료 기준(DoD 묶음)**

  * `/api/v1/skills/tree`가 유저 진행도와 함께 DAG 반환
  * React 스킬 트리 UI가 모바일/태블릿에서 60fps 스크롤/줌
  * 잠금 규칙 엔진 단위 테스트 통과, 클릭→세션 시작 이벤트 로깅

---

## 4. 디렉터리 구조 & 코드 스캐폴딩

### 4.1 데이터 스키마(시드 JSON; Phase‑1: 파일, Phase‑2: DB)

```json
// app/data/skills.json (요약)
{
  "version": "2025-10-11",
  "nodes": [
    { "id": "add_1d", "label": "덧셈(한 자리)", "tier": 1, "kind": "core",
      "xp_per_try": 5, "xp_per_correct": 10, "xp_to_level": [0,50,150,300],
      "i18n": { "ko": "덧셈(한 자리)", "en": "Addition (1-digit)" } },
    { "id": "mul_table", "label": "구구단", "tier": 2, "kind": "core",
      "xp_per_try": 5, "xp_per_correct": 12, "xp_to_level": [0,60,180,360] },
    { "id": "ratio", "label": "비율", "tier": 3, "kind": "concept" },
    { "id": "linear_fn", "label": "1차함수", "tier": 4, "kind": "algebra" },
    { "id": "diff", "label": "미분", "tier": 5, "kind": "calculus",
      "requires": { "all_of": ["add_1d", "mul_table", "ratio", "linear_fn"], "min_level": 2 },
      "boss": "tier4_exam" }
  ],
  "edges": [
    { "from": "add_1d", "to": "mul_table", "type": "requires" },
    { "from": "mul_table", "to": "ratio", "type": "enables" },
    { "from": "ratio", "to": "linear_fn", "type": "requires" },
    { "from": "linear_fn", "to": "diff", "type": "requires" }
  ]
}
```

> **원칙**: 노드에 `requires`(ALL/ANY, `min_level`)를 직접 명시 → 간단한 DAG. `boss`는 해당 티어의 평가 id.

### 4.2 FastAPI 스키마/서비스/라우터(요약)

**Pydantic 스키마**

```py
# app/schemas/skill.py
from pydantic import BaseModel, Field
from typing import Optional, List, Dict

class Requires(BaseModel):
    all_of: List[str] = Field(default_factory=list)
    any_of: List[str] = Field(default_factory=list)
    min_level: int = 1  # 0..3

class SkillNode(BaseModel):
    id: str
    label: str
    tier: int
    kind: str
    requires: Optional[Requires] = None
    xp_per_try: int = 0
    xp_per_correct: int = 0
    xp_to_level: List[int] = [0, 50, 150, 300]
    boss: Optional[str] = None

class SkillEdge(BaseModel):
    from_: str = Field(alias="from")
    to: str
    type: str

class SkillGraph(BaseModel):
    version: str
    nodes: List[SkillNode]
    edges: List[SkillEdge]

class UserSkillProgress(BaseModel):
    skill_id: str
    level: int  # 0 locked, 1 learned, 2 practiced, 3 mastered
    xp: int

class SkillGraphWithProgress(BaseModel):
    graph: SkillGraph
    progress: Dict[str, UserSkillProgress]
    unlocked: Dict[str, bool]
```

**규칙 엔진**

```py
# app/services/skill_rules.py
from typing import Dict
from app.schemas.skill import SkillNode, SkillGraph, UserSkillProgress

def is_unlocked(node: SkillNode, progress: Dict[str, UserSkillProgress]) -> bool:
    req = node.requires
    if not req: 
        return True
    # ALL 조건
    for sid in getattr(req, "all_of", []):
        if progress.get(sid, UserSkillProgress(skill_id=sid, level=0, xp=0)).level < req.min_level:
            return False
    # ANY 조건
    any_of = getattr(req, "any_of", [])
    if any_of:
        if not any(progress.get(sid, UserSkillProgress(skill_id=sid, level=0, xp=0)).level >= req.min_level for sid in any_of):
            return False
    # 보스전 체크는 별도(티어 통과 후 트리거)
    return True
```

**라우터**

```py
# app/api/v1/skills.py
from fastapi import APIRouter, Depends
from app.schemas.skill import SkillGraphWithProgress
from app.services.skill_store import load_graph, load_progress_for_user
from app.services.skill_rules import is_unlocked

router = APIRouter(prefix="/skills", tags=["skills"])

@router.get("/tree", response_model=SkillGraphWithProgress)
async def get_skill_tree(user_id: str | None = None):
    graph = load_graph()
    progress = load_progress_for_user(user_id)  # Phase-1: 메모리/파일, Phase-2: DB
    unlocked = {n.id: is_unlocked(n, progress) for n in graph.nodes}
    return {"graph": graph, "progress": progress, "unlocked": unlocked}
```

> **오류는 RFC 9457 공통 핸들러 적용**, 성공은 평문 JSON.

### 4.3 React 컴포넌트(요약: React Flow 사용 예)

```tsx
// frontend/src/components/SkillTree.tsx
import React, { useMemo } from "react";
import ReactFlow, { Background, Controls, Node, Edge } from "reactflow";
import "reactflow/dist/style.css";

type SkillNode = { id:string; label:string; tier:number; kind:string };
type SkillEdge = { from:string; to:string; type:string };
type ApiRes = { graph: { nodes:SkillNode[]; edges:SkillEdge[] }, unlocked: Record<string, boolean> };

export function SkillTree({ data }: { data: ApiRes }) {
  const nodes: Node[] = useMemo(() =>
    data.graph.nodes.map(n => ({
      id: n.id,
      position: { x: n.tier * 220, y: (hash(n.id)%10) * 80 }, // 간단 배치(실서비스에선 dagre)
      data: { label: n.label, unlocked: data.unlocked[n.id] },
      style: {
        borderRadius: 12,
        padding: 8,
        border: data.unlocked[n.id] ? "2px solid #2c7" : "2px dashed #999",
        background: data.unlocked[n.id] ? "#f2fff6" : "#f7f7f7"
      }
    })), [data]);

  const edges: Edge[] = useMemo(() =>
    data.graph.edges.map(e => ({ id: `${e.from}-${e.to}`, source: e.from, target: e.to, animated: !data.unlocked[e.to] })), [data]);

  return (
    <div style={{ width:"100%", height:"70vh" }} aria-label="Skill tree">
      <ReactFlow nodes={nodes} edges={edges} fitView>
        <Background />
        <Controls />
      </ReactFlow>
    </div>
  );
}

function hash(s:string){ let h=0; for (let i=0;i<s.length;i++) h=(h*31 + s.charCodeAt(i))|0; return Math.abs(h); }
```

**상호작용 규칙(UX)**

* **탭/엔터 키**로 포커스 이동(키보드 네비), **Space**로 세부정보·연습 시작
* 노드 상태: `Locked(회색)` / `Unlockable(점선+애니메이트 엣지)` / `Unlocked(실선, 초록)` / `Mastered(별 아이콘)`
* 툴팁: 난이도 라벨·필요 선행 스킬·내 현재 수준/XP
* **보스전 노드**는 왕관 아이콘, 통과 시 하위 티어 일괄 해제

### 4.4 진행도 갱신(예시)

```py
# app/api/v1/skills_progress.py
from fastapi import APIRouter
from app.schemas.skill import UserSkillProgress
router = APIRouter(prefix="/skills", tags=["skills"])

@router.post("/progress")
async def update_progress(payload: dict):
    # payload: { "session_id": "...", "skill_id": "mul_table", "correct": true, "elapsed_ms": 1200 }
    # 규칙: correct → xp += xp_per_correct, else xp += xp_per_try
    # xp_to_level 기준으로 level 업, 보스전 통과 시 다음 티어 조건 체크…
    return {"ok": True}
```

> **Phase‑1**: 파일/메모리 저장, **Phase‑2**: DB(`user_skill`, `skill`, `skill_edge`) 테이블 도입.

---

## 5. 다음 의사결정 (3가지)

1. **해제 규칙**: `ALL`+`min_level`만 쓸까요, `ANY`도 허용할까요?

   * 제안: **ALL(기본) + ANY(선택)** 모두 지원. 예: “비율 또는 분수” 중 하나만 알아도 통과.
2. **학년 범위 밖 노드(예: 미분) 노출 방식**:

   * 제안 A: **원거리 잠금(희미하게 표시 + 툴팁 “먼 미래 콘텐츠”)** → 동기부여
   * 제안 B: **완전 비표시** → 단순화
     → 기본은 **A** 권장(부모·교사 모드에서만 진하게)
3. **레이아웃 라이브러리**:

   * **React Flow(+dagre 레이아웃)** vs **Cytoscape.js**.
     → 모바일 상호작용/에디터 친화성 고려 시 **React Flow** 권장.

---

### 보너스: 예시 커리큘럼 매핑(요약)

* **Tier 1(1학년)**: `add_1d`, `sub_1d`
* **Tier 2(1~2학년)**: `mul_table`, `div_table` ← (req: add/sub level ≥ 2)
* **Tier 3(3~4학년)**: `fraction`, `decimal`, `ratio` ← (req: mul/div level ≥ 2)
* **Tier 4(중등 초입)**: `linear_fn`, `equation_basic` ← (req: ratio∧fraction ≥ 2)
* **Tier 5(고등)**: `limit_intro`, `diff` ← (req: linear_fn ≥ 2, ratio ≥ 2, add/mul ≥ 2; 보스: `tier4_exam`)

> 위 티어는 **노출 정책**(원거리 잠금)과 함께 단계적으로 확장 가능합니다.

---

## QA/관측/정책 메모

* **접근성**: 포커스 링, `aria-label`, 대비 4.5:1, 터치 48dp
* **성능**: 노드 100개 기준 initial JSON ≤ 50KB(필드 축소), 가상 스크롤/뷰포트 culling
* **정책**: `calc.360me.app`는 **noindex** 유지, 광고는 **비개인화**(아동 보호)
* **분석 이벤트**:

  * `skill_viewed {skill_id, tier}`
  * `skill_unlocked {skill_id, method:'xp'|'boss'}`
  * `session_started_from_tree {skill_id}`
  * `boss_passed {boss_id, tries}`

---

필요하면 **`skills.json` 초안**과 **React Flow 기반 첫 화면**을 바로 PR로 만들어 드리겠습니다.
우선 위 **3가지 의사결정**만 정해주시면, 스프린트 범위를 고정하고 진행할게요.
