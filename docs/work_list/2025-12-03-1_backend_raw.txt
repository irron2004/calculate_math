{"task_id":"Task 2025-12-03-1","owner_role":"backend","status":"blocked","summary":"Added normalized session/prerequisite helpers plus the new `/api/v1/skills/nodes/{node_id}/practice-plan` endpoint so the frontend can fetch tier/group labels and launch parameters for any skill node, and introduced regression tests and a report for the feature; `pytest tests/test_practice_plan.py` is currently blocked because `app/routers/practice.py:1` still contains a diff artifact that raises a SyntaxError during import.","artifacts_out":[{"type":"report","uri":"reports/backend/2025-12-03-1/practice_plan.md","note":"Change summary and blocked test log"}],"edits":[{"path":"app/routers/skills.py","content":"diff --git a/app/routers/skills.py b/app/routers/skills.py\nindex 5349132..514a5f5 100644\n--- a/app/routers/skills.py\n+++ b/app/routers/skills.py\n@@ -5,7 +5,7 @@ import logging\n from copy import deepcopy\n from functools import lru_cache\n from pathlib import Path\n-from typing import Any, Dict, Optional\n+from typing import Any, Dict, Iterable, Optional\n \n from fastapi import APIRouter, Depends, HTTPException, Query, Request, Response, status\n from pydantic import BaseModel, Field\n@@ -37,6 +37,8 @@ logger = logging.getLogger(\"calculate_service.api.skills\")\n _SKILL_UI_PATH = Path(__file__).resolve().parent.parent / \"data\" / \"skills.ui.json\"\n _LEGACY_SKILL_UI_PATH = _SKILL_UI_PATH.parent / \".old\" / _SKILL_UI_PATH.name\n \n+DEFAULT_PRACTICE_PROBLEM_COUNT = 6\n+\n \n def _resolve_skill_ui_path() -> Path | None:\n     if _SKILL_UI_PATH.exists():\n@@ -141,6 +143,60 @@ def _serialise_skill_progress(\n     return progress\n \n \n+def _normalise_problem_count(session_meta: Dict[str, Any]) -> int:\n+    explicit = session_meta.get(\"problem_count\")\n+    if isinstance(explicit, int) and explicit > 0:\n+        return explicit\n+    candidate = session_meta.get(\"parameters\", {}).get(\"count\")\n+    if isinstance(candidate, int) and candidate > 0:\n+        return candidate\n+    return DEFAULT_PRACTICE_PROBLEM_COUNT\n+\n+\n+def _normalise_session_meta(session_meta: Dict[str, Any] | None) -> Dict[str, Any]:\n+    meta = dict(session_meta or {})\n+    normalised: Dict[str, Any] = {\n+        \"concept\": meta.get(\"concept\"),\n+        \"step\": meta.get(\"step\"),\n+        \"generator\": meta.get(\"generator\"),\n+        \"parameters\": dict(meta.get(\"parameters\") or {}),\n+    }\n+    normalised[\"problem_count\"] = _normalise_problem_count({**meta, **normalised})\n+    return normalised\n+\n+\n+def _summarise_prerequisites(requirements: Optional[Iterable[Dict[str, Any]]]) -> Dict[str, Any]:\n+    items = list(requirements or [])\n+    met_count = sum(1 for requirement in items if requirement.get(\"met\"))\n+    unmet = [requirement for requirement in items if not requirement.get(\"met\")]\n+    return {\n+        \"total\": len(items),\n+        \"met\": met_count,\n+        \"all_met\": len(items) == met_count,\n+        \"missing\": [\n+            {\n+                \"skill_id\": requirement.get(\"skill_id\"),\n+                \"label\": requirement.get(\"label\"),\n+                \"required_level\": requirement.get(\"min_level\"),\n+                \"current_level\": requirement.get(\"current_level\"),\n+            }\n+            for requirement in unmet\n+        ],\n+    }\n+\n+\n+def _lookup_group(\n+    group_id: Optional[str],\n+    groups: Iterable[Dict[str, Any]],\n+) -> Dict[str, Any] | None:\n+    if not group_id:\n+        return None\n+    for group in groups:\n+        if group.get(\"id\") == group_id:\n+            return group\n+    return None\n+\n+\n @router.get(\"/skills/tree\")\n async def api_get_skill_tree(\n     request: Request,\n@@ -284,4 +340,126 @@ async def api_update_skill_progress(\n     }\n \n \n+@router.get(\"/skills/nodes/{node_id}/practice-plan\")\n+async def api_get_practice_plan(\n+    node_id: str,\n+    request: Request,\n+    user_id: Optional[str] = Query(None, description=\"Optional user id override\"),\n+    user: UserRecord | None = Depends(get_optional_user),\n+) -> Dict[str, Any]:\n+    try:\n+        bipartite_graph = get_bipartite_graph()\n+        course_steps = get_course_steps()\n+        atomic_skills = get_atomic_skills()\n+    except BipartiteSpecError as exc:  # pragma: no cover - validated elsewhere\n+        logger.exception(\"Failed to load bipartite graph for practice plan\")\n+        raise HTTPException(\n+            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n+            detail={\"message\": \"스킬 그래프를 불러오는 중 문제가 발생했습니다.\"},\n+        ) from exc\n+\n+    store = _resolve_progress_store(request)\n+    effective_user_id = user.id if user is not None else user_id\n+    snapshot, progress_error = _select_snapshot(store, effective_user_id)\n+    node_progress = _serialise_node_progress(course_steps, snapshot)\n+    skill_progress = _serialise_skill_progress(atomic_skills, snapshot)\n+\n+    projection = build_skill_tree_projection(\n+        graph=bipartite_graph,\n+        node_progress=node_progress,\n+        skill_progress=skill_progress,\n+    )\n+\n+    target_node: Dict[str, Any] | None = None\n+    for node in projection.get(\"nodes\", []):\n+        if node.get(\"id\") == node_id:\n+            target_node = node\n+            break\n+\n+    if target_node is None:\n+        raise HTTPException(\n+            status_code=status.HTTP_404_NOT_FOUND,\n+            detail={\"message\": f\"스킬 노드 '{node_id}'를 찾을 수 없습니다.\"},\n+        )\n+\n+    group_entry = _lookup_group(target_node.get(\"group\"), projection.get(\"groups\") or [])\n+    tier_value = int(target_node.get(\"tier\") or 0)\n+    tier_payload = {\n+        \"value\": tier_value,\n+        \"label\": f\"Tier {tier_value}\" if tier_value else \"Tier 미정\",\n+    }\n+    group_payload = None\n+    if group_entry:\n+        group_payload = {\n+            \"id\": group_entry.get(\"id\"),\n+            \"label\": group_entry.get(\"label\"),\n+            \"order\": group_entry.get(\"order\"),\n+        }\n+    elif target_node.get(\"group\"):\n+        group_payload = {\n+            \"id\": target_node.get(\"group\"),\n+            \"label\": target_node.get(\"group\"),\n+            \"order\": None,\n+        }\n+\n+    prerequisites = list(target_node.get(\"requires\") or [])\n+    prereq_summary = _summarise_prerequisites(prerequisites)\n+    teaches = list(target_node.get(\"teaches\") or [])\n+    session_config = target_node.get(\"session\") or {}\n+    session_summary = _normalise_session_meta(session_config if session_config else None)\n+\n+    skill_ids = [teach.get(\"skill_id\") for teach in teaches if teach.get(\"skill_id\")]\n+    practice_launch = {\n+        **session_summary,\n+        \"course_step_id\": target_node.get(\"id\"),\n+        \"skill_ids\": skill_ids,\n+    }\n+    blocked_reasons: list[str] = []\n+    if not session_config:\n+        blocked_reasons.append(\"missing_session_config\")\n+    if not prereq_summary[\"all_met\"]:\n+        blocked_reasons.append(\"prerequisites_unmet\")\n+    practice_launch[\"ready\"] = len(blocked_reasons) == 0\n+    practice_launch[\"blocked_reasons\"] = blocked_reasons\n+\n+    progress_meta = {\n+        \"user_id\": snapshot.user_id if snapshot else effective_user_id,\n+        \"updated_at\": snapshot.updated_at.isoformat() if snapshot else None,\n+    }\n+\n+    diagnostics: Dict[str, Any] | None = None\n+    if progress_error is not None:\n+        diagnostics = {\n+            \"progress\": {\n+                \"message\": \"진행도 정보를 불러올 수 없어 기본 값을 사용합니다.\",\n+                \"kind\": progress_error.__class__.__name__,\n+            }\n+        }\n+\n+    return {\n+        \"node\": {\n+            \"id\": target_node.get(\"id\"),\n+            \"label\": target_node.get(\"label\"),\n+            \"course\": target_node.get(\"course\"),\n+            \"lens\": target_node.get(\"lens\"),\n+            \"tier\": tier_payload[\"value\"],\n+            \"tier_label\": tier_payload[\"label\"],\n+            \"group\": group_payload,\n+            \"state\": target_node.get(\"state\"),\n+            \"xp\": target_node.get(\"xp\"),\n+            \"progress\": target_node.get(\"progress\"),\n+        },\n+        \"session\": session_config or None,\n+        \"session_summary\": session_summary,\n+        \"practice_launch\": practice_launch,\n+        \"prerequisites\": prerequisites,\n+        \"prerequisite_summary\": prereq_summary,\n+        \"teaches\": teaches,\n+        \"lrc_min\": target_node.get(\"lrc_min\") or {},\n+        \"misconceptions\": target_node.get(\"misconceptions\") or [],\n+        \"progress_context\": progress_meta,\n+        \"diagnostics\": diagnostics,\n+    }\n+\n+\n __all__ = [\"router\"]\n"},{"path":"tests/test_practice_plan.py","content":"diff --git a/tests/test_practice_plan.py b/tests/test_practice_plan.py\nnew file mode 100755\nindex 0000000..648425d\n--- /dev/null\n+++ b/tests/test_practice_plan.py\n@@ -0,0 +1,66 @@\n+import httpx\n+import pytest\n+\n+from app import create_app\n+from app.bipartite_loader import reset_bipartite_graph_cache\n+from app.config import get_settings\n+from app.problem_bank import reset_cache as reset_problem_cache\n+from app.progress_store import reset_progress_store\n+from app.template_engine import reset_engine as reset_template_engine\n+\n+pytestmark = pytest.mark.asyncio\n+\n+\n+@pytest.fixture\n+def skill_app(tmp_path, monkeypatch):\n+    attempts_path = tmp_path / \"attempts.db\"\n+    monkeypatch.setenv(\"ATTEMPTS_DATABASE_PATH\", str(attempts_path))\n+    monkeypatch.setenv(\"SESSION_TOKEN_SECRET\", \"test-secret\")\n+\n+    get_settings.cache_clear()  # type: ignore[attr-defined]\n+    reset_problem_cache()\n+    reset_template_engine()\n+    reset_progress_store()\n+    reset_bipartite_graph_cache()\n+\n+    app = create_app()\n+\n+    try:\n+        yield app\n+    finally:\n+        reset_problem_cache()\n+        reset_template_engine()\n+        reset_progress_store()\n+        reset_bipartite_graph_cache()\n+        get_settings.cache_clear()  # type: ignore[attr-defined]\n+\n+\n+@pytest.fixture\n+async def client(skill_app):\n+    transport = httpx.ASGITransport(app=skill_app, lifespan=\"on\")\n+    async with httpx.AsyncClient(transport=transport, base_url=\"http://testserver\") as async_client:\n+        yield async_client\n+\n+\n+async def test_practice_plan_exposes_session_metadata(client: httpx.AsyncClient) -> None:\n+    tree_response = await client.get(\"/api/v1/skills/tree\")\n+    assert tree_response.status_code == 200\n+    tree_payload = tree_response.json()\n+    assert tree_payload[\"nodes\"], \"skill tree must include nodes\"\n+    target_node = tree_payload[\"nodes\"][0]\n+\n+    plan_response = await client.get(f\"/api/v1/skills/nodes/{target_node['id']}/practice-plan\")\n+    assert plan_response.status_code == 200\n+    plan = plan_response.json()\n+\n+    assert plan[\"node\"][\"id\"] == target_node[\"id\"]\n+    assert \"practice_launch\" in plan\n+    assert plan[\"practice_launch\"][\"course_step_id\"] == target_node[\"id\"]\n+    assert \"tier_label\" in plan[\"node\"]\n+    assert isinstance(plan[\"prerequisites\"], list)\n+    assert \"prerequisite_summary\" in plan\n+\n+\n+async def test_practice_plan_for_unknown_node_returns_404(client: httpx.AsyncClient) -> None:\n+    response = await client.get(\"/api/v1/skills/nodes/UNKNOWN-NODE/practice-plan\")\n+    assert response.status_code == 404\n"},{"path":"reports/backend/2025-12-03-1/practice_plan.md","content":"diff --git a/reports/backend/2025-12-03-1/practice_plan.md b/reports/backend/2025-12-03-1/practice_plan.md\nnew file mode 100755\nindex 0000000..28b3529\n--- /dev/null\n+++ b/reports/backend/2025-12-03-1/practice_plan.md\n@@ -0,0 +1,12 @@\n+# Practice Plan Endpoint Summary\n+\n+## Changes\n+- Added helper utilities in `app/routers/skills.py` for normalising session metadata and prerequisite summaries.\n+- Introduced `GET /api/v1/skills/nodes/{node_id}/practice-plan` to surface tier/group labels, prerequisites, and launch parameters for the selected skill node.\n+- Added `tests/test_practice_plan.py` to cover the new endpoint's happy path and 404 behaviour using the full FastAPI stack.\n+\n+## Testing\n+```\n+pytest tests/test_practice_plan.py\n+```\n+Result: **blocked** — FastAPI app import fails because `app/routers/practice.py` currently contains a diff artifact and raises `SyntaxError`. Tests for the new endpoint could not run until the practice router module is restored to valid Python.\n"}],"changed_files":["app/routers/skills.py","tests/test_practice_plan.py","reports/backend/2025-12-03-1/practice_plan.md"],"action_items":[{"assignee":"senior_engineer","action":"Restore `app/routers/practice.py` to valid Python so the FastAPI app can import the router and re-run `pytest tests/test_practice_plan.py` to validate the new practice-plan endpoint.","priority":"medium"}],"handoff_to":["senior_engineer"],"confidence":0.64}
