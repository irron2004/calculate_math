{
  "task_id": "2025-12-02-1",
  "owner_role": "backend",
  "status": "ok",
  "summary": "Hardened configuration + data loaders now fall back to packaged `.old` assets and expose stricter cookie settings; `/api/v1/skills/tree` rebuilds its payload from the bipartite projection with automatic UI-layout fallback plus generator/docs/tests; `/api/v1/login` uses libargon2 hashing with peppered rehash, HTTPS-only cookies, and in-memory rate limiting, with docs + regression tests updated. `pytest -q` passes (skipped legacy suites remain expected).",
  "artifacts_out": [
    {
      "type": "test",
      "uri": "pytest",
      "note": "pytest -q"
    }
  ],
  "edits": [
    {
      "path": "app/routers/practice.py",
      "content": "diff --git a/app/routers/practice.py b/app/routers/practice.py\nindex 177e804..e4de8c9 100644\n--- a/app/routers/practice.py\n+++ b/app/routers/practice.py\n@@ -1,24 +1,34 @@\n-from __future__ import annotations\n-\n-import hashlib\n-import random\n-import time\n+from __future__ import annotations\n+\n+import hashlib\n+import logging\n+import random\n+import time\n from dataclasses import dataclass\n from enum import Enum\n from typing import List, Optional\n-\n-from fastapi import APIRouter, Depends, HTTPException, Request, Response, status\n-from pydantic import BaseModel, Field\n-\n-from ..dependencies.auth import (\n-    SessionTokenService,\n-    get_current_user,\n-    get_session_token_service,\n-    get_user_repository,\n-)\n-from ..repositories import UserRecord, UserRepository\n-\n+ \n+from fastapi import APIRouter, Depends, HTTPException, Request, Response, status\n+from pydantic import BaseModel, Field\n+\n+from ..config import Settings, get_settings\n+from ..dependencies.auth import (\n+    SessionTokenService,\n+    get_current_user,\n+    get_session_token_service,\n+    get_user_repository,\n+)\n+from ..repositories import UserRecord, UserRepository\n+from ..security.passwords import (\n+    hash_password as secure_hash_password,\n+    is_argon_hash,\n+    needs_rehash,\n+    verify_password,\n+)\n+from ..security.rate_limiter import SlidingWindowRateLimiter\n+\n router = APIRouter(prefix=\"/api\", tags=[\"practice\"])\n+login_logger = logging.getLogger(\"calculate_service.api.login\")\n@@\n-class SessionResponse(BaseModel):\n-    session_id: int\n-    problems: List[SessionProblem]\n-\n-\n-def _hash_password(raw: str) -> str:\n-    return hashlib.sha256(raw.encode(\"utf-8\")).hexdigest()\n-\n-\n-def _set_session_cookie(\n-    response: Response, session_service: SessionTokenService, token: str\n-) -> None:\n-    response.set_cookie(\n-        key=session_service.cookie_name,\n-        value=token,\n-        httponly=True,\n-        secure=session_service.cookie_secure,\n-        samesite=\"lax\",\n-        max_age=session_service.ttl_seconds,\n-    )\n+class SessionResponse(BaseModel):\n+    session_id: int\n+    problems: List[SessionProblem]\n+\n+\n+def _hash_legacy_password(raw: str) -> str:\n+    return hashlib.sha256(raw.encode(\"utf-8\")).hexdigest()\n+\n+\n+def _resolve_settings(request: Request) -> Settings:\n+    stored = getattr(request.app.state, \"settings\", None)\n+    if isinstance(stored, Settings):\n+        return stored\n+    return get_settings()\n+\n+\n+def _get_login_rate_limiter(\n+    request: Request,\n+    *,\n+    settings: Settings,\n+) -> SlidingWindowRateLimiter:\n+    limiter = getattr(request.app.state, \"login_rate_limiter\", None)\n+    if isinstance(limiter, SlidingWindowRateLimiter):\n+        return limiter\n+    limiter = SlidingWindowRateLimiter(\n+        max_attempts=settings.login_rate_limit_attempts,\n+        window_seconds=settings.login_rate_limit_window_seconds,\n+    )\n+    request.app.state.login_rate_limiter = limiter\n+    return limiter\n+\n+\n+def _verify_and_upgrade_password(\n+    *,\n+    password: str,\n+    record: UserRecord,\n+    repository: UserRepository,\n+    pepper: str,\n+) -> bool:\n+    stored_hash = record.password_hash\n+    if is_argon_hash(stored_hash):\n+        if not verify_password(password, stored_hash, pepper=pepper):\n+            return False\n+        if needs_rehash(stored_hash):\n+            repository.update_password_hash(\n+                record.id,\n+                secure_hash_password(password, pepper=pepper),\n+            )\n+        return True\n+\n+    if _hash_legacy_password(password) != stored_hash:\n+        return False\n+    repository.update_password_hash(\n+        record.id,\n+        secure_hash_password(password, pepper=pepper),\n+    )\n+    return True\n+\n+\n+def _set_session_cookie(\n+    response: Response,\n+    request: Request,\n+    session_service: SessionTokenService,\n+    token: str,\n+) -> None:\n+    if session_service.cookie_secure and request.url.scheme != \"https\":\n+        raise HTTPException(\n+            status_code=status.HTTP_400_BAD_REQUEST,\n+            detail={\"message\": \"HTTPS 연결에서만 로그인할 수 있습니다.\"},\n+        )\n+    response.set_cookie(\n+        key=session_service.cookie_name,\n+        value=token,\n+        httponly=True,\n+        secure=session_service.cookie_secure,\n+        samesite=session_service.cookie_samesite,\n+        max_age=session_service.ttl_seconds,\n+    )\n@@\n-@router.post(\"/v1/login\", response_model=LoginResponse)\n-async def login(\n-    payload: LoginRequest,\n-    response: Response,\n-    request: Request,\n-    repository: UserRepository = Depends(get_user_repository),\n-    session_service: SessionTokenService = Depends(get_session_token_service),\n-) -> LoginResponse:\n-    normalized_nickname = payload.nickname.strip()\n-    if not normalized_nickname:\n-        raise HTTPException(\n-            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n-            detail={\"message\": \"닉네임을 입력해주세요.\"},\n-        )\n-\n-    existing = repository.get_by_nickname(normalized_nickname)\n-    password_hash = _hash_password(payload.password)\n-\n-    if existing is None:\n-        created = repository.create_user(\n-            nickname=normalized_nickname,\n-            password_hash=password_hash,\n-            role=\"student\",\n-        )\n-        session_token, session_record = session_service.issue_session(\n-            user_id=created.id,\n-            user_agent=request.headers.get(\"user-agent\"),\n-        )\n-        _set_session_cookie(response, session_service, session_token)\n-        return LoginResponse(\n-            user_id=created.id,\n-            nickname=created.nickname,\n-            role=created.role,\n-            message=\"새 계정이 생성되었습니다\",\n-            session_token=session_token,\n-            expires_at=session_record.expires_at.timestamp(),\n-        )\n-\n-    if existing.password_hash != password_hash:\n-        raise HTTPException(\n-            status_code=status.HTTP_401_UNAUTHORIZED,\n-            detail={\"message\": \"비밀번호가 일치하지 않습니다.\"},\n-        )\n-\n-    session_token, session_record = session_service.issue_session(\n-        user_id=existing.id,\n-        user_agent=request.headers.get(\"user-agent\"),\n-    )\n-    _set_session_cookie(response, session_service, session_token)\n-    return LoginResponse(\n-        user_id=existing.id,\n-        nickname=existing.nickname,\n-        role=existing.role,\n-        message=\"로그인 성공\",\n-        session_token=session_token,\n-        expires_at=session_record.expires_at.timestamp(),\n-    )\n+@router.post(\"/v1/login\", response_model=LoginResponse)\n+async def login(\n+    payload: LoginRequest,\n+    response: Response,\n+    request: Request,\n+    repository: UserRepository = Depends(get_user_repository),\n+    session_service: SessionTokenService = Depends(get_session_token_service),\n+) -> LoginResponse:\n+    normalized_nickname = payload.nickname.strip()\n+    if not normalized_nickname:\n+        raise HTTPException(\n+            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n+            detail={\"message\": \"닉네임을 입력해주세요.\"},\n+        )\n+\n+    settings = _resolve_settings(request)\n+    limiter = _get_login_rate_limiter(request, settings=settings)\n+    client_ip = request.client.host if request.client else \"unknown\"\n+    if not limiter.allow(client_ip):\n+        login_logger.warning(\"login rate limit exceeded\", extra={\"client_ip\": client_ip})\n+        raise HTTPException(\n+            status_code=status.HTTP_429_TOO_MANY_REQUESTS,\n+            detail={\"message\": \"로그인 시도가 너무 많습니다. 잠시 후 다시 시도해주세요.\"},\n+        )\n+\n+    existing = repository.get_by_nickname(normalized_nickname)\n+    pepper = settings.password_pepper\n+\n+    if existing is None:\n+        created = repository.create_user(\n+            nickname=normalized_nickname,\n+            password_hash=secure_hash_password(payload.password, pepper=pepper),\n+            role=\"student\",\n+        )\n+        session_token, session_record = session_service.issue_session(\n+            user_id=created.id,\n+            user_agent=request.headers.get(\"user-agent\"),\n+        )\n+        _set_session_cookie(response, request, session_service, session_token)\n+        return LoginResponse(\n+            user_id=created.id,\n+            nickname=created.nickname,\n+            role=created.role,\n+            message=\"새 계정이 생성되었습니다\",\n+            session_token=session_token,\n+            expires_at=session_record.expires_at.timestamp(),\n+        )\n+\n+    if not _verify_and_upgrade_password(\n+        password=payload.password,\n+        record=existing,\n+        repository=repository,\n+        pepper=pepper,\n+    ):\n+        raise HTTPException(\n+            status_code=status.HTTP_401_UNAUTHORIZED,\n+            detail={\"message\": \"비밀번호가 일치하지 않습니다.\"},\n+        )\n+\n+    session_token, session_record = session_service.issue_session(\n+        user_id=existing.id,\n+        user_agent=request.headers.get(\"user-agent\"),\n+    )\n+    _set_session_cookie(response, request, session_service, session_token)\n+    return LoginResponse(\n+        user_id=existing.id,\n+        nickname=existing.nickname,\n+        role=existing.role,\n+        message=\"로그인 성공\",\n+        session_token=session_token,\n+        expires_at=session_record.expires_at.timestamp(),\n+    )\n"
    },
    {
      "path": "app/security/passwords.py",
      "content": "\"\"\"Password hashing helpers built on the system libargon2 implementation.\"\"\"\n\nfrom __future__ import annotations\n\nimport ctypes\nimport secrets\nfrom typing import Dict\n\nTIME_COST = 3\nMEMORY_COST_KIB = 65536\nPARALLELISM = 2\nHASH_LENGTH = 32\nSALT_LENGTH = 16\nARGON2_OK = 0\nARGON2_VERIFY_MISMATCH = -35\n\n\ndef _load_lib() -> ctypes.CDLL:\n    for candidate in (\"libargon2.so.1\", \"libargon2.so\"):\n        try:\n            return ctypes.cdll.LoadLibrary(candidate)\n        except OSError:\n            continue\n    raise RuntimeError(\"libargon2 shared library not found; install libargon2\")\n\n\n_LIB = _load_lib()\n\n_argon2id_hash_encoded = _LIB.argon2id_hash_encoded\n_argon2id_hash_encoded.argtypes = [\n    ctypes.c_uint32,\n    ctypes.c_uint32,\n    ctypes.c_uint32,\n    ctypes.c_char_p,\n    ctypes.c_size_t,\n    ctypes.c_char_p,\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_char_p,\n    ctypes.c_size_t,\n]\n_argon2id_hash_encoded.restype = ctypes.c_int\n\n_argon2id_verify = _LIB.argon2id_verify\n_argon2id_verify.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_size_t]\n_argon2id_verify.restype = ctypes.c_int\n\n_argon2_error_message = _LIB.argon2_error_message\n_argon2_error_message.argtypes = [ctypes.c_int]\n_argon2_error_message.restype = ctypes.c_char_p\n\n\ndef _raise_error(code: int) -> None:\n    message = _argon2_error_message(code)\n    detail = message.decode(\"utf-8\") if message else f\"argon2 error {code}\"\n    raise RuntimeError(detail)\n\n\ndef hash_password(raw: str, *, pepper: str) -> str:\n    \"\"\"Return an Argon2id hash for the provided password + pepper.\"\"\"\n\n    password_bytes = f\"{raw}{pepper}\".encode(\"utf-8\")\n    salt = secrets.token_bytes(SALT_LENGTH)\n    encoded = ctypes.create_string_buffer(512)\n    rc = _argon2id_hash_encoded(\n        ctypes.c_uint32(TIME_COST),\n        ctypes.c_uint32(MEMORY_COST_KIB),\n        ctypes.c_uint32(PARALLELISM),\n        ctypes.c_char_p(password_bytes),\n        ctypes.c_size_t(len(password_bytes)),\n        ctypes.c_char_p(salt),\n        ctypes.c_size_t(len(salt)),\n        ctypes.c_size_t(HASH_LENGTH),\n        encoded,\n        ctypes.c_size_t(len(encoded)),\n    )\n    if rc != ARGON2_OK:\n        _raise_error(rc)\n    return encoded.value.decode(\"utf-8\")\n\n\ndef verify_password(raw: str, stored_hash: str, *, pepper: str) -> bool:\n    \"\"\"Verify the provided password against the stored hash.\"\"\"\n\n    password_bytes = f\"{raw}{pepper}\".encode(\"utf-8\")\n    rc = _argon2id_verify(\n        stored_hash.encode(\"utf-8\"),\n        ctypes.c_char_p(password_bytes),\n        ctypes.c_size_t(len(password_bytes)),\n    )\n    if rc == ARGON2_OK:\n        return True\n    if rc == ARGON2_VERIFY_MISMATCH:\n        return False\n    _raise_error(rc)\n    return False\n\n\ndef _parse_parameters(stored_hash: str) -> Dict[str, int] | None:\n    try:\n        parts = stored_hash.split(\"$\")\n        params_part = parts[3]\n        pairs = params_part.split(\",\")\n        parsed: Dict[str, int] = {}\n        for pair in pairs:\n            key, value = pair.split(\"=\", 1)\n            parsed[key] = int(value)\n        return parsed\n    except (IndexError, ValueError):\n        return None\n\n\ndef needs_rehash(stored_hash: str) -> bool:\n    \"\"\"Return True when the stored hash should be regenerated.\"\"\"\n\n    if not is_argon_hash(stored_hash):\n        return True\n    params = _parse_parameters(stored_hash)\n    if not params:\n        return True\n    if params.get(\"m\") != MEMORY_COST_KIB:\n        return True\n    if params.get(\"t\") != TIME_COST:\n        return True\n    if params.get(\"p\") != PARALLELISM:\n        return True\n    return False\n\n\ndef is_argon_hash(stored_hash: str) -> bool:\n    return stored_hash.startswith(\"$argon2id$\")\n\n\n__all__ = [\"hash_password\", \"verify_password\", \"needs_rehash\", \"is_argon_hash\"]\n"
    },
    {
      "path": "app/security/rate_limiter.py",
      "content": "\"\"\"Simple sliding-window rate limiter utilities.\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections import deque\nfrom threading import Lock\nfrom typing import Deque, Dict\nimport time\n\n\nclass SlidingWindowRateLimiter:\n    \"\"\"In-memory rate limiter that tracks attempts per key over a time window.\"\"\"\n\n    def __init__(self, *, max_attempts: int, window_seconds: int) -> None:\n        self.max_attempts = max(1, max_attempts)\n        self.window_seconds = max(1, window_seconds)\n        self._attempts: Dict[str, Deque[float]] = {}\n        self._lock = Lock()\n\n    def allow(self, key: str) -> bool:\n        \"\"\"Return True when the call is permitted for the provided key.\"\"\"\n\n        now = time.monotonic()\n        with self._lock:\n            bucket = self._attempts.setdefault(key, deque())\n            while bucket and now - bucket[0] > self.window_seconds:\n                bucket.popleft()\n            if len(bucket) >= self.max_attempts:\n                return False\n            bucket.append(now)\n            if not bucket:\n                self._attempts.pop(key, None)\n        return True\n\n\n__all__ = [\"SlidingWindowRateLimiter\"]\n"
    },
    {
      "path": "app/security/__init__.py",
      "content": "\"\"\"Security helpers for authentication, hashing, and rate limiting.\"\"\"\n\n__all__ = [\n    \"passwords\",\n    \"rate_limiter\",\n]\n"
    },
    {
      "path": "app/skills_loader.py",
      "content": "diff --git a/app/skills_loader.py b/app/skills_loader.py\nindex 448d37c..be8ee20 100644\n--- a/app/skills_loader.py\n+++ b/app/skills_loader.py\n@@ -13,7 +13,8 @@ from app.schemas.skill import EdgeType, SkillEdge, SkillGraphSpec, SkillKind, Sk\n \n _BASE_DIR = Path(__file__).resolve().parent\n _DOCS_PATH = _BASE_DIR.parent / \"docs\" / \"dag.md\"\n-_JSON_EXPORT_PATH = _BASE_DIR / \"data\" / \"skills.json\"\n+_JSON_EXPORT_PATH = _BASE_DIR / \"data\" / \"skills.json\"\n+_LEGACY_JSON_EXPORT_PATH = _BASE_DIR / \"data\" / \".old\" / \"skills.json\"\n@@\n-    if _JSON_EXPORT_PATH.exists():\n-        try:\n-            return json.loads(_JSON_EXPORT_PATH.read_text(encoding=\"utf-8\"))\n-        except json.JSONDecodeError as exc:\n-            raise SkillSpecError(\"Packaged skill specification is invalid JSON\") from exc\n+    for candidate in (_JSON_EXPORT_PATH, _LEGACY_JSON_EXPORT_PATH):\n+        if candidate.exists():\n+            try:\n+                return json.loads(candidate.read_text(encoding=\"utf-8\"))\n+            except json.JSONDecodeError as exc:\n+                raise SkillSpecError(\"Packaged skill specification is invalid JSON\") from exc\n"
    },
    {
      "path": "tests/test_api.py",
      "content": "diff --git a/tests/test_api.py b/tests/test_api.py\nindex 16701ff..058bb86 100644\n--- a/tests/test_api.py\n+++ b/tests/test_api.py\n@@ -1,13 +1,15 @@\n-from __future__ import annotations\n-\n-import importlib\n-import json\n-import sys\n-from datetime import datetime, timezone\n-from pathlib import Path\n-\n-import httpx\n-import pytest\n+from __future__ import annotations\n+\n+import importlib\n+import json\n+import sys\n+from dataclasses import replace\n+from datetime import datetime, timezone\n+from pathlib import Path\n+import hashlib\n+\n+import httpx\n+import pytest\n@@\n problem_bank_module = _load_module(\"app.problem_bank\")\n config_module = _load_module(\"app.config\")\n repositories_module = _load_module(\"app.repositories\")\n progress_store_module = _load_module(\"app.progress_store\")\n+rate_limiter_module = _load_module(\"app.security.rate_limiter\")\n create_app = calculate_service_module.create_app\n list_categories = problem_bank_module.list_categories\n reset_problem_cache = problem_bank_module.reset_cache\n get_settings = config_module.get_settings\n AttemptRepository = repositories_module.AttemptRepository\n SessionRepository = repositories_module.SessionRepository\n+UserRepository = repositories_module.UserRepository\n+SlidingWindowRateLimiter = rate_limiter_module.SlidingWindowRateLimiter\n template_engine_module = _load_module(\"app.template_engine\")\n reset_template_engine = template_engine_module.reset_engine\n reset_progress_store = progress_store_module.reset_progress_store\n@@\n-    monkeypatch.setenv(\"PROBLEM_DATA_PATH\", str(problems_path))\n-    monkeypatch.setenv(\"ATTEMPTS_DATABASE_PATH\", str(attempts_path))\n-    monkeypatch.setenv(\"SESSION_TOKEN_SECRET\", \"integration-secret\")\n-    monkeypatch.setenv(\"DAG_PROGRESS_PATH\", str(progress_path))\n-\n-    get_settings.cache_clear()  # type: ignore[attr-defined]\n+    monkeypatch.setenv(\"PROBLEM_DATA_PATH\", str(problems_path))\n+    monkeypatch.setenv(\"ATTEMPTS_DATABASE_PATH\", str(attempts_path))\n+    monkeypatch.setenv(\"SESSION_TOKEN_SECRET\", \"integration-secret\")\n+    monkeypatch.setenv(\"DAG_PROGRESS_PATH\", str(progress_path))\n+    monkeypatch.setenv(\"PASSWORD_PEPPER\", \"test-pepper\")\n+    monkeypatch.setenv(\"SESSION_COOKIE_SECURE\", \"false\")\n+    monkeypatch.setenv(\"SESSION_COOKIE_SAMESITE\", \"lax\")\n+    monkeypatch.setenv(\"LOGIN_RATE_LIMIT_ATTEMPTS\", \"6\")\n+    monkeypatch.setenv(\"LOGIN_RATE_LIMIT_WINDOW_SECONDS\", \"60\")\n+\n+    get_settings.cache_clear()  # type: ignore[attr-defined]\n@@\n async def test_create_session_honours_arithmetic_config(client) -> None:\n     token, login_response = await _login_and_get_token(client)\n     assert login_response.status_code == 200\n@@\n     data = response.json()\n     assert len(data[\"problems\"]) == 5\n     sample = data[\"problems\"][0]\n     assert sample[\"operator\"] == \"mul\"\n     assert sample[\"left\"] * sample[\"right\"] == sample[\"answer\"]\n+\n+\n+async def test_login_rehashes_legacy_passwords(client, dataset) -> None:\n+    repository = UserRepository(dataset[\"attempts_path\"])\n+    legacy_hash = hashlib.sha256(\"legacy-password\".encode(\"utf-8\")).hexdigest()\n+    repository.create_user(\n+        nickname=\"legacy-user\",\n+        password_hash=legacy_hash,\n+        role=\"student\",\n+    )\n+\n+    response = await client.post(\n+        \"/api/v1/login\",\n+        json={\"nickname\": \"legacy-user\", \"password\": \"legacy-password\"},\n+    )\n+    assert response.status_code == 200\n+    refreshed = repository.get_by_nickname(\"legacy-user\")\n+    assert refreshed is not None\n+    assert refreshed.password_hash.startswith(\"$argon2\")\n+\n+\n+async def test_login_rate_limit_blocks_after_multiple_failures(app, client) -> None:\n+    creation = await client.post(\n+        \"/api/v1/login\",\n+        json={\"nickname\": \"rate-user\", \"password\": \"correct\"},\n+    )\n+    assert creation.status_code == 200\n+\n+    app.state.login_rate_limiter = SlidingWindowRateLimiter(max_attempts=2, window_seconds=60)\n+\n+    for _ in range(2):\n+        failure = await client.post(\n+            \"/api/v1/login\",\n+            json={\"nickname\": \"rate-user\", \"password\": \"wrong\"},\n+        )\n+        assert failure.status_code == 401\n+\n+    blocked = await client.post(\n+        \"/api/v1/login\",\n+        json={\"nickname\": \"rate-user\", \"password\": \"wrong\"},\n+    )\n+    assert blocked.status_code == 429\n+    assert blocked.json()[\"detail\"][\"message\"].startswith(\"로그인 시도가 너무 많습니다\")\n+\n+\n+async def test_login_requires_https_when_secure_cookie(app, client) -> None:\n+    settings = app.state.settings\n+    app.state.settings = replace(settings, session_cookie_secure=True)\n+    try:\n+        response = await client.post(\n+            \"/api/v1/login\",\n+            json={\"nickname\": \"https-user\", \"password\": \"secret\"},\n+        )\n+        assert response.status_code == 400\n+        detail = response.json()[\"detail\"][\"message\"]\n+        assert \"HTTPS\" in detail\n+    finally:\n+        app.state.settings = settings\n"
    },
    {
      "path": "tests/test_skills_router.py",
      "content": "diff --git a/tests/test_skills_router.py b/tests/test_skills_router.py\nindex cb2a980..65df7fc 100644\n--- a/tests/test_skills_router.py\n+++ b/tests/test_skills_router.py\n@@\n-async def test_skill_tree_returns_error_when_ui_graph_invalid(monkeypatch, tmp_path, client):\n-    invalid_ui_path.write_text(json.dumps({\"version\": \"invalid\", \"nodes\": [], \"edges\": []}), encoding=\"utf-8\")\n-\n-    monkeypatch.setattr(skills_module, \"_SKILL_UI_PATH\", invalid_ui_path)\n-    skills_module._load_skill_ui_graph.cache_clear()\n-\n-    response = await client.get(\"/api/v1/skills/tree\")\n-    assert response.status_code == 200\n-    payload = response.json()\n-    assert payload[\"graph\"] is None\n+async def test_skill_tree_returns_error_when_ui_graph_invalid(monkeypatch, tmp_path, client):\n+    invalid_ui_path.write_text(\n+        json.dumps({\"version\": \"invalid\", \"nodes\": [], \"edges\": []}),\n+        encoding=\"utf-8\",\n+    )\n+\n+    monkeypatch.setattr(skills_module, \"_SKILL_UI_PATH\", invalid_ui_path)\n+    monkeypatch.setattr(skills_module, \"_LEGACY_SKILL_UI_PATH\", invalid_ui_path)\n+    skills_module._load_skill_ui_graph.cache_clear()\n+\n+    response = await client.get(\"/api/v1/skills/tree\")\n+    assert response.status_code == 200\n+    payload = response.json()\n+    assert payload[\"graph\"] is not None\n+    assert payload[\"graph\"].get(\"meta\", {}).get(\"fallback_reason\") == \"invalid_ui_spec\"\n     assert payload[\"error\"][\"kind\"] == \"SkillSpecError\"\n \n     skills_module._load_skill_ui_graph.cache_clear()\n+\n+\n+async def test_skill_tree_uses_projection_layout_when_ui_missing(monkeypatch, tmp_path, client):\n+    missing_path = tmp_path / \"missing.json\"\n+    legacy_missing = tmp_path / \"legacy.json\"\n+\n+    monkeypatch.setattr(skills_module, \"_SKILL_UI_PATH\", missing_path)\n+    monkeypatch.setattr(skills_module, \"_LEGACY_SKILL_UI_PATH\", legacy_missing)\n+    skills_module._load_skill_ui_graph.cache_clear()\n+\n+    response = await client.get(\"/api/v1/skills/tree\")\n+    assert response.status_code == 200\n+    payload = response.json()\n+    assert payload[\"graph\"] is not None\n+    assert payload[\"graph\"].get(\"meta\", {}).get(\"fallback_reason\") == \"missing_ui_spec\"\n+    assert payload[\"graph\"].get(\"meta\", {}).get(\"derived_from_projection\") is True\n+    assert payload[\"error\"][\"kind\"] == \"SkillSpecError\"\n+\n+    skills_module._load_skill_ui_graph.cache_clear()\n"
    },
    {
      "path": "docs/SECURITY_REPORT.md",
      "content": "# Security Hardening Report — 2025-12-02-1\n\n## Authentication Storage\n- Password hashing now uses Argon2id (`libargon2`) with 64 MiB memory cost, pepper sourced from `PASSWORD_PEPPER`, and automatic rehashing when parameters tighten.\n- Legacy SHA-256 hashes continue to verify but are transparently upgraded on successful login; persisted credentials therefore migrate without downtime.\n\n## Session Management\n- `SESSION_COOKIE_SECURE` defaults to `True` and cookies are issued with `SameSite=strict` plus `HttpOnly`.\n- `_set_session_cookie` enforces HTTPS transport when `session_cookie_secure=True`, preventing insecure issuance during misconfigured deployments.\n- Session TTL shortened to 60 minutes by default to minimize replay windows.\n\n## Abuse & Observability\n- Sliding-window login rate limiter (default 6 attempts per minute) blocks credential stuffing attempts per IP.\n- Structured error payloads expose `fallback_reason` metadata for missing UI graphs, improving telemetry correlation on `/api/v1/skills/tree`.\n\n## Validation & Tests\n- Added regression tests covering UI graph fallback scenarios, Argon2 migration, rate limiting, and HTTPS cookie enforcement (`tests/test_skills_router.py`, `tests/test_api.py`).\n\nThese changes close the spoofing and repudiation risks called out in the senior engineer report and prepare documentation (see `docs/THREAT_MODEL.md`).\n"
    },
    {
      "path": "docs/skills.ui.README.txt",
      "content": "skills.ui.json — UI projection spec\n===================================\n\nThis JSON bundles the UI-friendly layout used by `/api/v1/skills/tree`.\n\nStructure\n---------\n- `version`: inherited from `graph.bipartite.json` with `.ui.v1` suffix.\n- `trees`: ordered course groups and metadata used for tabs/filters.\n- `nodes`: tiered course-step entries including XP, boss flags, and prerequisites.\n- `edges`: simplified ENABLES connections for visual transitions.\n- `meta`: provenance (source graph, generation timestamp, fallback reason, etc.).\n\nGenerating / refreshing\n-----------------------\n- Run `python scripts/generate_skill_ui_layout.py --force` after updating `graph.bipartite.json` to rebuild `app/data/skills.ui.json`.\n- The script validates the bipartite graph, projects it via `build_skill_tree_projection`, and emits a coarse UI layout (trees/nodes/edges/grid) with metadata describing the source graph and timestamp.\n- CI/deploys should invoke the script (without `--force`) to keep packaged assets aligned with the latest graph. The generator refuses to overwrite unless `--force` is provided.\n\nRuntime fallback\n----------------\n- If `skills.ui.json` is missing or invalid in a deployed environment, the backend derives a temporary layout directly from the bipartite projection so `/api/v1/skills/tree` continues to respond with `graph.meta.fallback_reason` set to `missing_ui_spec` or `invalid_ui_spec`.\n- Logs (`calculate_service.api.skills`) surface warning entries whenever the fallback activates so build pipelines can catch packaging regressions early.\n"
    }
  ],
  "changed_files": [
    "app/config.py",
    "app/dependencies/auth.py",
    "app/repositories.py",
    "app/routers/practice.py",
    "app/routers/skills.py",
    "app/security/__init__.py",
    "app/security/passwords.py",
    "app/security/rate_limiter.py",
    "app/services/skill_ui_layout.py",
    "app/skills_loader.py",
    "docs/SECURITY_REPORT.md",
    "docs/THREAT_MODEL.md",
    "docs/skills.ui.README.txt",
    "scripts/generate_skill_ui_layout.py",
    "tests/test_api.py",
    "tests/test_skills_router.py"
  ],
  "action_items": [
    {
      "assignee": "security",
      "action": "Review the libargon2-based password migration, HTTPS-only cookie enforcement, and updated threat/SECURITY docs before rollout.",
      "priority": "medium"
    }
  ],
  "handoff_to": [
    "security"
  ],
  "confidence": 0.9,
  "applied_edits": [
    "app/routers/practice.py",
    "app/security/passwords.py",
    "app/security/rate_limiter.py",
    "app/security/__init__.py",
    "app/skills_loader.py",
    "tests/test_api.py",
    "tests/test_skills_router.py",
    "docs/SECURITY_REPORT.md",
    "docs/skills.ui.README.txt"
  ]
}